package dolevYao

import java.io.{BufferedReader, InputStreamReader}
import scala.util.parsing.combinator.syntactical.StandardTokenParsers
import scala.util.parsing.input.*

object Main {
  def main(args: Array[String]): Unit = {
    // Read the protocol from the standard input.
    val stdin = new BufferedReader(new InputStreamReader(System.in))
    val protocolInput = LazyList.from(0)
      // Alternate between S and R for each step.
      .map(step => if step % 2 == 0 then S else R)
      // Read input for each step.
      .map(participant => {
        print("Enter step for " + participant + " (newline to terminate): ")
        (participant, stdin.readLine())
      })
      // Until a newline is presented.
      .takeWhile((_, input) => input.nonEmpty)
      .toList
    verify(protocolInput)
  }

}
  def verify(protocolInput: List[(Participant, String)]): Boolean = {
    print("Parsing...")
    // Parse the operations and convert into a protocol step.
    val protocolSteps: List[ProtocolStep] = protocolInput.map((participant, input) =>
      ProtocolStep(participant, DolevYaoParser.parseString(input).getOrElse(Identity)))
    println("OK!")
    println("Validating...")
    // Let the user know which steps are invalid.
    for((step, i) <- protocolSteps.zipWithIndex) {
      println("Step " + i + " - " + (if step.isValidStep then "ok" else "not ok"))
    }
    // Construct the protocol and validate it.
    val protocol = Protocol(protocolSteps)
    if(!protocol.isValidProtocol) {
      println("Invalid protocol. Aborting.")
      throw Exception("Invalid protocol. Aborting.")
    }
    println("OK!")
    println(protocol)
    // Construct the automaton.
    println("Constructing the automaton...")
    val automaton = Automaton()
    // Add the single path from 0 to 1.
    val addedPaths = automaton.addNewPath(0, 1, protocol.steps.head.operation)
    val participants = Set(S, R, Z)
    // Add the saboteur words.
    val saboteurWords = Set(Decrypt(Z, Identity))
      ++ participants.map(p => Encrypt(p, Identity))
      ++ participants.map(p => Desindex(p, Identity))
      ++ participants.map(p => Index(p, Identity))
      ++ participants.map(p => Delete(Identity))
    for(sw <- saboteurWords) {
      automaton.addNewPath(0, 0, sw)
    }
    // Get all possible participant pairs.
    val participantPairs = participants
      .subsets(2)
      .map(_.toList)
      .flatMap(l => List((l.head, l.last), (l.last, l.head)))
      .toList
    // For intermediate steps, add self-loops for each of its possible replayed version.
    for(step <- protocol.steps.drop(1)) {
      for(participantPair <- participantPairs) {
        val op = replayedOperation(step.operation, step.sender, participantPair._1, participantPair._2)
        // Add the new operation as a self-loop only if the operation cannot be trivially generated by Z. Otherwise,
        // the automaton already has a path 0->0 with the new operation due to the existence of self-loops through
        // saboteur words.
        if(!isValidOperation(Z, op)) {
          automaton.addNewPath(0, 0, op)
        }
      }
    }
    println(automaton)

    val (secure, collapsingPath) = DolevYaoAlgorithm.isSecure(automaton)

    if secure then
      println("Protocol secure under Dolev-Yao")
    else {
      println("Protocol not secure under Dolev-Yao")
      val pathRepr = collapsingPath.getOrElse(List.empty).map(_.toString).mkString(" ")
      println("The adversary can compose: " + pathRepr + " = " + IdentityOperator().toString)
    }

    secure
  }
